mainmodule leanmd {

  readonly CProxy_Main mainProxy;
  readonly CProxy_Patch patchArray;
  readonly CProxy_Compute computeArray;
  readonly CkGroupID mCastGrpID;

  readonly int patchArrayDimX;		// X dimension of the Patch array
  readonly int patchArrayDimY;		// Y dimension of the Patch array
  readonly int patchArrayDimZ;		// Y dimension of the Patch array
  readonly int finalStepCount;		// number of steps at which the cells should
  readonly int firstLdbStep;		// do load balancing after this many steps
  readonly int ldbPeriod;		// do load balancing every period
  readonly int ftPeriod;		// do load balancing every period
  readonly BigReal stepTime;

  mainchare [migratable] Main {
    entry Main(CkArgMsg* msg);
    entry void allDone();
    entry void lbBarrier();
    entry void ftBarrier();
    entry void startUpDone();
  };

  message ParticleDataMsg{
    partData part[];
  };

  message ParticleForceMsg{
    force forces[];
  };

  array [3D] Patch {
    entry Patch();
    entry void createComputes();
    entry void createSection();
    entry void reduceForces(CkReductionMsg *msg);
    entry void resume();
    entry void ftresume();
    entry void receiveParticles(CkVec<Particle> updates);
    entry void ResumeFromSync();
    entry void resumeAfterLB(int resume);

    entry void run() {
      atomic {
        if((thisIndex.x + thisIndex.y + thisIndex.z) == 0) {
          stepTime = CmiWallTimer();
        }
      }
      for(stepCount = 0; stepCount < finalStepCount; stepCount++) {
        atomic {
          sendPositions();
        }
        when reduceForces(CkReductionMsg *msg) {
          atomic {
            int i, lengthUp;
            int* forces = (int*)msg->getData();
            lengthUp = msg->getSize()/sizeof(BigReal);
            for(i = 0; i < lengthUp; i+=3){
              particles[i/3].fx += forces[i];
              particles[i/3].fy += forces[i+1];
              particles[i/3].fz += forces[i+2];
            }
            delete msg;
            updateProperties();
          }
        }
        if (stepCount > 0 && (stepCount % 20) == 0) {
          atomic {
            migrateParticles();
          }
          for(updateCount = 0; updateCount < inbrs; updateCount++) {
            when receiveParticles(CkVec<Particle> &updates) atomic {
              for(int i=0; i < updates.length(); i++) {
                particles.push_back(updates[i]);
              }
            }
          }
        }
        atomic {
          if (thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && stepCount%20==0) {
            double timer = CmiWallTimer();
            CkPrintf("Step %d Benchmark Time %f ms/step, Total Time Elapsed %f ms\n", 
                      stepCount, ((timer - stepTime)/20)*1000, timer);
            stepTime = timer;
          }
        }
        if (perform_lb) {
          atomic {
            AtSync();
            LBTurnInstrumentOff();
            perform_lb=false;
          }
          when resumeAfterLB(int resume) atomic {
            stepTime = CkWallTimer();
            LBTurnInstrumentOn();
          }
        }
      }
      atomic {
        int contrib;
        contribute(sizeof(int),&contrib,CkReduction::sum_double,CkCallback(CkIndex_Main::allDone(), mainProxy));
        //contribute(CkCallback(CkIndex_Main::allDone(), mainProxy));
      }
    };
};

array [6D] Compute {
  entry Compute();
  entry void interact(ParticleDataMsg *msg);
  entry void ResumeFromSync();
};
};
