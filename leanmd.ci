mainmodule leanmd {

  readonly CProxy_Main mainProxy;
  readonly CProxy_Patch patchArray;
  readonly CProxy_Compute computeArray;
  readonly CkGroupID mCastGrpID;

  readonly int patchArrayDimX;		// X dimension of the Patch array
  readonly int patchArrayDimY;		// Y dimension of the Patch array
  readonly int patchArrayDimZ;		// Y dimension of the Patch array
  readonly int finalStepCount;		// number of steps at which the cells should
  readonly int firstLdbStep;		// do load balancing after this many steps
  readonly int ldbPeriod;		// do load balancing every period
  readonly int ftPeriod;		// do load balancing every period
  readonly BigReal stepTime;

  mainchare [migratable] Main {
    entry Main(CkArgMsg* msg);
    entry void allDone();
    entry void ftBarrier();
    entry void startUpDone();
    entry [reductiontarget] void energySumP(double energyP);
    entry [reductiontarget] void energySumK(double energyK);
  };

  message ParticleDataMsg{
    partData part[];
  };

  message ParticleForceMsg{
    force forces[];
  };

  array [3D] Patch {
    entry Patch();
    entry void createComputes();
    entry void createSection();
    entry [reductiontarget] void reduceForces(BigReal forces[n], int n);
    entry void ftresume();
    entry void receiveParticles(CkVec<Particle> updates);
    entry void ResumeFromSync();
    entry void nextStep();

    entry void doStep() {
      atomic {
	sendPositions();
      }
      when reduceForces(BigReal forces[n], int n) {
        atomic {
	  updateForce(forces,n);
          delete forces;
          updateProperties();
        }
      }
      if (stepCount > 0 && (stepCount %  MIGRATE_STEPCOUNT) == 0) {
        atomic {
          migrateParticles();
        }
        for(updateCount = 0; updateCount < inbrs; updateCount++) {
          when receiveParticles(CkVec<Particle> &updates) atomic {
            for(int i=0; i < updates.length(); i++) {
              particles.push_back(updates[i]);
            }
          }
        }
      }
      atomic {
        if (stepCount && thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && stepCount%20==0) {
          double timer = CkWallTimer();
          CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
                    stepCount, ((timer - stepTime)/20)*1000);
          stepTime = CkWallTimer();
        }
	stepCount++;
	patchArray(thisIndex.x,thisIndex.y,thisIndex.z).nextStep();
      }
    };
};

array [6D] Compute {
  entry Compute();
  entry void interact(ParticleDataMsg *msg);
  entry void ResumeFromSync();
};
};
