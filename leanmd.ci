mainmodule leanmd {

  readonly CProxy_Main mainProxy;       //central controller
  readonly CProxy_Cell cellArray;     //array that houses atoms
  readonly CProxy_Compute computeArray; //computational kernels
  readonly CProxy_Comm commProxy; //comm
  readonly CkGroupID mCastGrpID;      //multicast group handle
  readonly CProxy_StaticSchedule staticSch;

  readonly int cellArrayDimX;		// X dimension of the Cell array
  readonly int cellArrayDimY;		// Y dimension of the Cell array
  readonly int cellArrayDimZ;		// Y dimension of the Cell array
  readonly int finalStepCount;		// number of steps in the simulaion
  readonly int firstLdbStep;		// begin load balancing after this many steps
  readonly int ldbPeriod;		// load balancing period

  group StaticSchedule {
    entry StaticSchedule();
  };

  //central controller chare
  mainchare [migratable] Main {
    entry Main(CkArgMsg* msg);
    entry [reductiontarget] void computesCreated(); //called when computes have been created
    entry [reductiontarget] void energySumP(double iP, double fP);  //reduction of potential energy
    entry [reductiontarget] void energySumK(double iK, double fK);  //reduction of kinetic energy
    entry void setupFinished();

    //this get called after the main constructor has called cell array constructor
    entry void run() {
      //compute array created, call for section creation
      when computesCreated() atomic {
        computeArray.doneInserting();
        CkPrintf("Computes: %d .... created\n", (NUM_NEIGHBORS/2+1)*cellArrayDimX*cellArrayDimY*cellArrayDimZ);
        CkPrintf("Starting simulation .... \n\n");
	fflush(stdout);
	startTime = CkWallTimer();
        cellArray.coordRun();
        computeArray.coordRun();
        //cellArry.run();
        //computeArray.run();
      }
      //receive intial and final energies and compare
      when energySumP(double fP, double iP),
           energySumK(double fK, double iK) atomic {
	double endTime = CkWallTimer() - startTime;
	CkPrintf("total time = %f\n", endTime - startTime);
        if(abs(fP + fK - iP - iK)>ENERGY_VAR) {
          CkPrintf("Energy value has varied significantly from %E to %E\n",iP+iK,fP+fK);
          CkPrintf("\nEnergy conservation test failed for maximum allowed variation of %E units.\nSIMULATION UNSUCCESSFULL\n",ENERGY_VAR);  
	  fflush(stdout);
        } else {
          CkPrintf("\nEnergy conservation test passed for maximum allowed variation of %E units.\nSIMULATION SUCCESSFULL \n",ENERGY_VAR);
	  fflush(stdout);
        }
        CkExit();
      }
    };
  };

  //message used to convey particle to computes
  message ParticleDataMsg{
    vec3 part[];
  };

  //chares to house atoms
  array [3D] Cell {
    entry Cell();  
    entry void createComputes();    //call to insert computes that I need  
    entry void ResumeFromSync();    //resume from here after load balancing
    entry [reductiontarget] void reduceForces(vec3 forces[n], int n);   //receives forces from my computes on my atoms
    entry void transition();
    entry void commRelease();
    entry void startMigrate(int pe);
    entry void migrateDone(int dummy);

    entry void coordRun() {
      atomic {
        // do initial registration with the Comm
        //CkPrintf("(%d,%d,%d): tell local comm (pe %d) this element exists\n",
        //thisIndex.x, thisIndex.y, thisIndex.z, CkMyPe());

        thisCell = linearize3D(thisIndex);
        //CkPrintf("%d: cell %d running\n", CkMyPe(), thisCell);
        fflush(stdout);

        commProxy[CkMyPe()].ckLocal()->registerCell(thisIndex);

        // current state is 0, haven't started yet
        currentState = 0;
	stepCount = 0;

        // initialize some values here
        StaticSchedule& sched = *staticSch.ckLocalBranch();
        
        CkAssert(sched.cellTransition.find(thisCell) != sched.cellTransition.end());
        stateCount = sched.cellTransition[thisCell].size();
        //printf("cell %d: found %d states\n", thisCell, stateCount);
      }
      while (currentState < stateCount) {
        atomic {
          StaticSchedule& sched = *staticSch.ckLocalBranch();
          current = sched.cellTransition[thisCell][currentState];
          //printf("cell %d: currentState is %d, waitTask = %d\n",
          //thisCell, currentState, current.waitTask);
          CkAssert(current.thisObject.idx.x1 == thisIndex.x &&
		   current.thisObject.idx.y1 == thisIndex.y &&
		   current.thisObject.idx.z1 == thisIndex.z);

          switch (current.taskType) {
          case 0: sendState(); break;
          case 1: updateState(); break;
	  case 3: migrateState(); break;
          default:
            CkPrintf("invalid state %d for a cell, id = %d\n", current.taskType, thisCell);
            CkAssert(0);
            break;
          }
        }
        when transition() { }
        atomic {
          currentState++;
        }
      }
    };

    entry void sendState() {
      atomic {
        // make sure it's executing on the PE the schedule expects it to
        //CkPrintf("%d: running cell sendState() on pe %d\n", thisCell, current.pe);
	//fflush(stdout);
        CkAssert(CkMyPe() == current.pe);
      }

      if (current.waitTask != -5) { when commRelease() { } }
      //atomic { CkPrintf("released\n"); }
      atomic {
	sendPositions();
	CkPrintf("%d: sending positions from cell %d\n", CkMyPe(), thisCell); fflush(stdout);
      }
      atomic {
        // objType 2 means no object
        if (current.relObject.objType != 2) {
          Obj& obj = current.relObject;
          commProxy[CkMyPe()].releaseNext(obj.objType, obj.idx);
          CkPrintf("%d: calling release from cell %d\n", CkMyPe(), thisCell); fflush(stdout);
        }
        transition();
      }
    };

    entry void updateState() {
      atomic {
        // make sure it's executing on the PE the schedule expects it to
        //CkPrintf("%d: running cell updateState() on pe %d\n", thisCell, current.pe);
	//fflush(stdout);
        CkAssert(CkMyPe() == current.pe);
      }
      if (current.waitTask != -5) { when commRelease() { } }
      when reduceForces(vec3 forces[n], int n) atomic {
        updateProperties(forces, n);
      }
      atomic {
        // objType 2 means no object
        if (current.relObject.objType != 2) {
          Obj& obj = current.relObject;
          commProxy[CkMyPe()].releaseNext(obj.objType, obj.idx);
          CkPrintf("%d: calling release from cell %d\n", CkMyPe(), thisCell); fflush(stdout);
        }
	// two states per iter
	stepCount++;
        transition();
      }
    };

    entry void migrateState() {
      atomic {
        CkPrintf("%d: cell %d migrating %d to %d\n", CkMyPe(), thisCell, CkMyPe(), current.pe);
	fflush(stdout);
        commProxy[CkMyPe()].startMigrate(thisIndex, current.pe);
        commProxy[CkMyPe()].ckLocal()->unregister(thisIndex);
      }
      when migrateDone(int dummy) atomic {
        // register with Comm on this pe
        commProxy[CkMyPe()].ckLocal()->registerCell(thisIndex);
      }
      atomic {
        transition();
      }
    };

    //function to perform iterations for Cells
    entry void run() {
      if(thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0) atomic {
          stepTime = CkWallTimer(); }

      atomic { createSection(); }

      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) {
        //send current atom positions to my computes 
        atomic { 
	  double sendTime = CkWallTimer();
	  sendPositions();
	  sendTime = CkWallTimer() - sendTime;
	}

        //update properties of atoms using new force values 
        when reduceForces(vec3 forces[n], int n) atomic {
	  double updateTime = CkWallTimer();
	  updateProperties(forces, n);
	  updateTime = CkWallTimer() - updateTime;
	}

        if (thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && 
          stepCount%20==0) atomic {
          CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
          stepCount, ((CkWallTimer() - stepTime)/20)*1000);
	  fflush(stdout);
          stepTime = CkWallTimer();
        }
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod == 0) {
          atomic { AtSync(); }
          when ResumeFromSync() atomic { 
            stepTime = CkWallTimer();
          }
        }
      }
      //everything done, reduction on kinetic energy
      atomic { contribute(2*sizeof(double),energy,CkReduction::sum_double,CkCallback(CkReductionTarget(Main,energySumK),mainProxy)); }
    };
  };

  //chares that do force computations for pair of cells
  array [6D] Compute {
    entry Compute();
    entry void ResumeFromSync();
    entry void calculateForces(ParticleDataMsg *msg);
    entry void transition();
    entry void commRelease();
    entry void migrateDone(int dummy);

    entry void coordRun() {
      atomic {
        // do initial registration with the Comm
        // @protocol always order these x1,x2,y1,y2...
        thisCompute = linearize6D(thisIndex);
        //CkPrintf("%d: compute %d running\n", CkMyPe(), thisCompute);
        //fflush(stdout);
        // CkPrintf("(%d,%d,%d,%d,%d,%d): tell local comm (pe %d) this element exists\n",
        //          thisIndex.x1, thisIndex.x2,
        //          thisIndex.y1, thisIndex.y2,
        //          thisIndex.z1, thisIndex.z2, CkMyPe());
        commProxy[CkMyPe()].ckLocal()->registerCompute(thisIndex);

        // current state is 0, haven't started yet
        currentState = 0;
	stepCount = 0;

        // initialize some values here
        StaticSchedule& sched = *staticSch.ckLocalBranch();
        CkAssert(sched.computeTransition.find(thisCompute) != sched.computeTransition.end());
	//if (sched.computeTransition.find(thisCompute) != sched.computeTransition.end())
	  stateCount = sched.computeTransition[thisCompute].size();
	//else
        //stateCount = 0;
        //CkPrintf("compute %d: found %d states\n", thisCompute, stateCount);
	fflush(stdout);
      }
      while (currentState < stateCount) {
        atomic {
           StaticSchedule& sched = *staticSch.ckLocalBranch();
           current = sched.computeTransition[thisCompute][currentState];
	   //CkPrintf("compute %d: currentState is %d, waitTask = %d\n",
	   //thisCompute, currentState, current.waitTask);
          CkAssert(current.thisObject.idx.x1 == thisIndex.x1 &&
		   current.thisObject.idx.y1 == thisIndex.y1 &&
		   current.thisObject.idx.z1 == thisIndex.z1 &&
		   current.thisObject.idx.x2 == thisIndex.x2 &&
		   current.thisObject.idx.y2 == thisIndex.y2 &&
		   current.thisObject.idx.z2 == thisIndex.z2);

          switch (current.taskType) {
          case 2: computeState(); break;
	  case 3: migrateState(); break;
          default:
            CkPrintf("invalid state %d for a compute, id = %d\n", current.taskType, thisCompute);
            CkAssert(0);
            break;
           }
        }
        when transition() { }
        atomic {
          currentState++;
        }
      }
    };

    entry void computeState() {
      atomic {
        // make sure it's executing on the PE the schedule expects it to
        //CkPrintf("%d: running compute %d, expected pe %d\n", CkMyPe(), thisCompute, current.pe);
	//fflush(stdout);
        CkAssert(CkMyPe() == current.pe);
      }
      if (current.waitTask != -5) { when commRelease() { } }
      if (thisIndex.x1 == thisIndex.x2 &&
          thisIndex.y1 == thisIndex.y2 &&
          thisIndex.z1 == thisIndex.z2) {
        when calculateForces(ParticleDataMsg *msg) atomic {
          CkPrintf("%d: compute from compute %d\n", CkMyPe(), thisCompute); fflush(stdout);
          selfInteract(msg);
        }
      } else {
        //receive positions from two cells - buffer the first one
        when calculateForces(ParticleDataMsg *msg) atomic { bufferedMsg = msg; }
        when calculateForces(ParticleDataMsg *msg) atomic { interact(msg);
          CkPrintf("%d: compute from compute %d\n", CkMyPe(), thisCompute); fflush(stdout);
        }
      }
      atomic {
        // objType 2 means no object
        if (current.relObject.objType != 2) {
          Obj& obj = current.relObject;
          commProxy[CkMyPe()].releaseNext(obj.objType, obj.idx);
          CkPrintf("%d: calling release from compute %d\n", CkMyPe(), thisCompute); fflush(stdout);
        }
	stepCount++;
        transition();
      }
    };

    entry void migrateState() {
      atomic {
        CkPrintf("%d: compute %d migrating %d to %d\n", CkMyPe(), thisCompute, CkMyPe(), current.pe);
        commProxy[CkMyPe()].startMigrateComp(thisIndex, current.pe);
        commProxy[CkMyPe()].ckLocal()->unregister(thisIndex);
      }
      when migrateDone(int dummy) atomic {
        // register with Comm on this pe
        commProxy[CkMyPe()].ckLocal()->registerCompute(thisIndex);
      }
      atomic {
        transition();
      }
    };

    entry void run() {
      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) {
        //self interaction check
        if(thisIndex.x1==thisIndex.x2 && thisIndex.y1==thisIndex.y2 && thisIndex.z1==thisIndex.z2) {
          when calculateForces(ParticleDataMsg *msg) atomic { selfInteract(msg); }
        } else {
          //receive positions from two cells - buffer the first one
          when calculateForces(ParticleDataMsg *msg) atomic { bufferedMsg = msg; }
          when calculateForces(ParticleDataMsg *msg) atomic { interact(msg); }
        }
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod== 0) {
          atomic { AtSync(); }
          when ResumeFromSync() atomic { }
        }
      }
      //everything done, reduction on potential energy
      atomic { contribute(2*sizeof(double),energy,CkReduction::sum_double,CkCallback(CkReductionTarget(Main,energySumP),mainProxy)); }
    };
  };

  group OnePerPE : CkArrayMap {
    entry OnePerPE();
  };
  group ComputeMap : CkArrayMap {
    entry ComputeMap();
  };
  group CellMap : CkArrayMap {
    entry CellMap();
  };

  message Startup;

  array [1d] Comm {
    entry Comm();
    entry [reductiontarget] void reduceForces(vec3 forces[n], int n);
    entry void warmup(Startup*);
    entry void warmupRed(int iter, int reducingCell, int globalID, int n, int computes[n]);
    entry void releaseNext(int type, CkIndex6D indx);
    entry void tryDeliver(ParticleDataMsg* m);
    entry void startMigrate(CkIndex3D, int pe);
    entry void startMigrateComp(CkIndex6D, int pe);
  };
};
