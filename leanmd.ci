mainmodule leanmd {

  readonly CProxy_Main mainProxy;       //central controller
  readonly CProxy_Patch patchArray;     //array that houses atoms
  readonly CProxy_Compute computeArray; //computational kernels
  readonly CkGroupID mCastGrpID;      //multicast group handle

  readonly int patchArrayDimX;		// X dimension of the Patch array
  readonly int patchArrayDimY;		// Y dimension of the Patch array
  readonly int patchArrayDimZ;		// Y dimension of the Patch array
  readonly int finalStepCount;		// number of steps in the simulaion
  readonly int firstLdbStep;		// begin load balancing after this many steps
  readonly int ldbPeriod;		// do load balancing every period
  readonly int ftPeriod;		// do fault tolerance backup every period
  readonly double stepTime;

  //central controller chare
  mainchare [migratable] Main {
    entry Main(CkArgMsg* msg);
    entry void allDone();     //called when simulation is done
    entry void ftBarrier();   //called when fault tolerance backup is done
    entry void startUpDone(); //called when initial set up is done
    entry [reductiontarget] void energySumP(double energyP);  //reduction of
    potential energy
      entry [reductiontarget] void energySumK(double energyK);  //reduction of
    kinetic energy
  };

  //message used to convey particle to computes
  message ParticleDataMsg{
    partData part[];
  };

  //chares to house atoms
  array [3D] Patch {
    entry Patch();  
    entry void createComputes();    //call to insert computes that I need  
    entry void createSection();     //creation multicast section of computes
    entry void ftresume();          //resume from here after fault tolerance
    backup
      entry void receiveParticles(CkVec<Particle> updates); //receive atoms that
    have migrated to neighboring patches to me
      entry void ResumeFromSync();    //resume from here after load balancing
    entry void nextStep();          //decide what to do after an iteration ends
    entry [reductiontarget] void reduceForces(double forces[n], int n);
    //receives forces from my computes on my atoms

    //function to perform one iteration of LeanMD
    entry void doStep() {
      atomic {
        sendPositions();    //send current atom positions to my computes
      }
      when reduceForces(double forces[n], int n) {
        atomic {
          updateForce(forces,n);      //update force values received from my computes
          updateProperties();   //update properties of atoms using new force
          values
        }
      }
      if (stepCount > 0 && (stepCount %  MIGRATE_STEPCOUNT) == 0) {
        atomic {
          migrateParticles(); //send atoms that have moved beyond my cell to
          neighbors
        }
        //receive particles from my neighbors
        for(updateCount = 0; updateCount < inbrs; updateCount++) {
          when receiveParticles(CkVec<Particle> &updates) atomic {
            for(int i=0; i < updates.length(); i++) {
              particles.push_back(updates[i]);    //add particles that have
              moved from neighboring patches to my cell
            }
          }
        }
      }
      atomic {
        if (stepCount && thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && stepCount%20==0) {
          double timer = CkWallTimer();
          CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
              stepCount, ((timer - stepTime)/20)*1000);
          stepTime = CkWallTimer();
        }
        stepCount++;
        patchArray(thisIndex.x,thisIndex.y,thisIndex.z).nextStep();
      }
    };
  };

  //chares that does the force computations for pair of patches
  array [6D] Compute {
    entry Compute();
    entry void interact(ParticleDataMsg *msg);  //receive current particle
    position from patches
      entry void ResumeFromSync();  
  };
};
