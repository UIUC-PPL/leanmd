mainmodule leanmd {

  readonly CProxy_Main mainProxy;       //central controller
  readonly CProxy_Cell cellArray;     //array that houses atoms
  readonly CProxy_Compute computeArray; //computational kernels
  readonly CkGroupID mCastGrpID;      //multicast group handle
  readonly CkGroupID commID;

  readonly int cellArrayDimX;		// X dimension of the Cell array
  readonly int cellArrayDimY;		// Y dimension of the Cell array
  readonly int cellArrayDimZ;		// Y dimension of the Cell array
  readonly int finalStepCount;		// number of steps in the simulaion
  readonly int firstLdbStep;		// begin load balancing after this many steps
  readonly int ldbPeriod;		// load balancing period

  group Comm {
    entry Comm();
    entry [reductiontarget] void reduceForces(vec3 forces[n], int n);
  };

  //central controller chare
  mainchare [migratable] Main {
    entry Main(CkArgMsg* msg);
    entry [reductiontarget] void computesCreated(); //called when computes have been created
    entry [reductiontarget] void energySumP(double iP, double fP);  //reduction of potential energy
    entry [reductiontarget] void energySumK(double iK, double fK);  //reduction of kinetic energy

    //this get called after the main constructor has called cell array constructor
    entry void run() {
      //compute array created, call for section creation
      when computesCreated() atomic {
        computeArray.doneInserting();
        CkPrintf("Computes: %d .... created\n", (NUM_NEIGHBORS/2+1)*cellArrayDimX*cellArrayDimY*cellArrayDimZ);
        CkPrintf("Starting simulation .... \n\n");
	fflush(stdout);
	startTime = CkWallTimer();
        cellArray.run();
        computeArray.run();
      }
      //receive intial and final energies and compare
      when energySumP(double fP, double iP), energySumK(double fK, double iK) atomic {
	double endTime = CkWallTimer() - startTime;
	CkPrintf("total time = %f\n", endTime - startTime);
        if(abs(fP + fK - iP - iK)>ENERGY_VAR) {
          CkPrintf("Energy value has varied significantly from %E to %E\n",iP+iK,fP+fK);
          CkPrintf("\nEnergy conservation test failed for maximum allowed variation of %E units.\nSIMULATION UNSUCCESSFULL\n",ENERGY_VAR);  
	  fflush(stdout);
        } else {
          CkPrintf("\nEnergy conservation test passed for maximum allowed variation of %E units.\nSIMULATION SUCCESSFULL \n",ENERGY_VAR);
	  fflush(stdout);
        }
        CkExit();
      }
    };
  };

  //message used to convey particle to computes
  message ParticleDataMsg{
    vec3 part[];
  };

  //chares to house atoms
  array [3D] Cell {
    entry Cell();  
    entry void createComputes();    //call to insert computes that I need  
    entry void ResumeFromSync();    //resume from here after load balancing
    entry [reductiontarget] void reduceForces(vec3 forces[n], int n);   //receives forces from my computes on my atoms

    //function to perform iterations for Cells
    entry void run() {
      if(thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0) atomic {
          stepTime = CkWallTimer(); }

      atomic { createSection(); }

      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) {
        //send current atom positions to my computes 
        atomic { 
	  double sendTime = CkWallTimer();
	  sendPositions();
	  sendTime = CkWallTimer() - sendTime;
	  if (stepCount == 1) {
	    CkPrintf("cell send %d %d %d %f\n", thisIndex.x,thisIndex.y,thisIndex.z, sendTime * 1000);
	  }
	}

        //update properties of atoms using new force values 
        when reduceForces(vec3 forces[n], int n) atomic {
	  double updateTime = CkWallTimer();
	  updateProperties(forces, n);
	  updateTime = CkWallTimer() - updateTime;
	  if (stepCount == 1) {
	    CkPrintf("cell update %d %d %d %f\n", thisIndex.x,thisIndex.y,thisIndex.z, updateTime * 1000);
	  }
	}

        if (thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && 
          stepCount%20==0) atomic {
          CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
          stepCount, ((CkWallTimer() - stepTime)/20)*1000);
	  fflush(stdout);
          stepTime = CkWallTimer();
        }
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod == 0) {
          atomic { AtSync(); }
          when ResumeFromSync() atomic { 
            stepTime = CkWallTimer();
          }
        }
      }
      //everything done, reduction on kinetic energy
      atomic { contribute(2*sizeof(double),energy,CkReduction::sum_double,CkCallback(CkReductionTarget(Main,energySumK),mainProxy)); }
    };
  };

  //chares that do force computations for pair of cells
  array [6D] Compute {
    entry Compute();
    entry void ResumeFromSync();
    entry void calculateForces(ParticleDataMsg *msg);

    entry void run() {
      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) {
        //self interaction check
        if(thisIndex.x1==thisIndex.x2 && thisIndex.y1==thisIndex.y2 && thisIndex.z1==thisIndex.z2) {
          when calculateForces(ParticleDataMsg *msg) atomic { selfInteract(msg); }
        } else {
          //receive positions from two cells - buffer the first one
          when calculateForces(ParticleDataMsg *msg) atomic { bufferedMsg = msg; }
          when calculateForces(ParticleDataMsg *msg) atomic { interact(msg); }
        }
	if (stepCount == 1) atomic {
	    CkPrintf("compute interact %d %d %d %d %d %d %f\n", thisIndex.x1,thisIndex.x2,thisIndex.y1,thisIndex.y2,thisIndex.z1,thisIndex.z2, computeTime * 1000);
	}
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod== 0) {
          atomic { AtSync(); }
          when ResumeFromSync() atomic { }
        }
      }
      //everything done, reduction on potential energy
      atomic { contribute(2*sizeof(double),energy,CkReduction::sum_double,CkCallback(CkReductionTarget(Main,energySumP),mainProxy)); }
    };
  };
};
