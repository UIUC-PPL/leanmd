mainmodule leanmd {

  readonly CProxy_Main mainProxy;       //central controller
  readonly CProxy_Cell cellArray;     //array that houses atoms
  readonly CProxy_Compute computeArray; //computational kernels
  readonly CProxy_PME pmeArray;
  readonly CkGroupID mCastGrpID;      //multicast group handle

  readonly int cellArrayDimX;		// X dimension of the Cell array
  readonly int cellArrayDimY;		// Y dimension of the Cell array
  readonly int cellArrayDimZ;		// Y dimension of the Cell array
  readonly int finalStepCount;		// number of steps in the simulaion
  readonly int firstLdbStep;		// begin load balancing after this many steps
  readonly int ldbPeriod;		// load balancing period

  //central controller chare
  mainchare [migratable] Main {
    entry Main(CkArgMsg* msg);
    entry [reductiontarget] void computesCreated(); //called when computes have been created
    entry [reductiontarget] void energySumP(double iP, double fP);  //reduction of potential energy
    entry [reductiontarget] void energySumK(double iK, double fK);  //reduction of kinetic energy

    //this get called after the main constructor has called cell array constructor
    entry void run() {
      //compute array created, call for section creation
      when computesCreated() atomic {
        computeArray.doneInserting();
        CkPrintf("Computes: %d .... created\n", (NUM_NEIGHBORS/2+1)*cellArrayDimX*cellArrayDimY*cellArrayDimZ);
        CkPrintf("Starting simulation .... \n\n");
        cellArray.run();
        computeArray.run();
      }
      //receive intial and final energies and compare
      when energySumP(double fP, double iP), energySumK(double fK, double iK) atomic {
        if(abs(fP + fK - iP - iK)>ENERGY_VAR) {
          CkPrintf("Energy value has varied significantly from %E to %E\n",iP+iK,fP+fK);
          CkPrintf("\nEnergy conservation test failed for maximum allowed variation of %E units.\nSIMULATION UNSUCCESSFULL\n",ENERGY_VAR);  
        } else {
          CkPrintf("\nEnergy conservation test passed for maximum allowed variation of %E units.\nSIMULATION SUCCESSFULL \n",ENERGY_VAR);
        }
        CkExit();
      }
    };
  };

  //message used to convey particle to computes
  message ParticleDataMsg{
    vec3 part[];
  };

  //chares to house atoms
  array [3D] Cell {
    entry Cell();  
    entry void createComputes();    //call to insert computes that I need  
    entry void ResumeFromSync();    //resume from here after load balancing
    entry [reductiontarget] void reduceForces(vec3 forces[n], int n);   //receives forces from my computes on my atoms
    entry void updateCharge(int n, double charges[n]);

    //function to perform iterations for Cells
    entry void run() {
      if(thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0) atomic {
          stepTime = CkWallTimer(); }

      atomic { createSection(); }

      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) {
        //send current atom positions to my computes 
        atomic {
          sendPositions();
          sendCharges();
        }

        //update properties of atoms using new force values 
        when reduceForces(vec3 forces[n], int n) atomic { updateProperties(forces, n); }
          
        when updateCharge(int n, double charges[n]) {}

        if (thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && 
          stepCount%20==0) atomic {
          CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
          stepCount, ((CkWallTimer() - stepTime)/20)*1000);
          stepTime = CkWallTimer();
        }
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod == 0) {
          atomic { AtSync(); }
          when ResumeFromSync() atomic { 
            stepTime = CkWallTimer();
          }
        }
      }
      //everything done, reduction on kinetic energy
      atomic { contribute(2*sizeof(double),energy,CkReduction::sum_double,CkCallback(CkReductionTarget(Main,energySumK),mainProxy)); }
    };
  };

  //chares that do force computations for pair of cells
  array [6D] Compute {
    entry Compute();
    entry void ResumeFromSync();
    entry void calculateForces(ParticleDataMsg *msg);

    entry void run() {
      for(stepCount = 1; stepCount <= finalStepCount; stepCount++) {
        //self interaction check
        if(thisIndex.x1==thisIndex.x2 && thisIndex.y1==thisIndex.y2 && thisIndex.z1==thisIndex.z2) {
          when calculateForces(ParticleDataMsg *msg) atomic { selfInteract(msg); }
        } else {
          //receive positions from two cells - buffer the first one
          when calculateForces(ParticleDataMsg *msg) atomic { bufferedMsg = msg; }
          when calculateForces(ParticleDataMsg *msg) atomic { interact(msg); }
        }
        //periodically call load balancer
        if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod== 0) {
          atomic { AtSync(); }
          when ResumeFromSync() atomic { }
        }
      }
      //everything done, reduction on potential energy
      atomic { contribute(2*sizeof(double),energy,CkReduction::sum_double,CkCallback(CkReductionTarget(Main,energySumP),mainProxy)); }
    };
  };
  
  array [2D] PME {
    entry PME();
    entry void recvCharges(int n, double remoteCharges[n]);
    entry void xAllToAll(int n, double remoteCharges[n]);
    entry void yAllToAll(int n, double remoteCharges[n]);
    entry void run() {
      for (stepCount = 0; stepCount < finalStepCount; stepCount++) {
        for (numZ = 0; numZ < cellArrayDimZ; numZ++) {
          when recvCharges(int n, double remoteCharges[n]) atomic {
            CkAssert(CHARGES_PER_CELL == n);
            memcpy(&charges[numZ * CHARGES_PER_CELL], remoteCharges, n);
          }
        }
        for (phase = 0; phase < 2; phase++) {
          atomic {
            for (int i = 0; i < CHARGES_PER_CELL * cellArrayDimZ; i++) {
              charges[i] += 10.8 * i;
            }
          }
          atomic {
            for (int x = 0; x < cellArrayDimX; x++) {
              thisProxy(x,thisIndex.y).xAllToAll(CHARGES_PER_CELL, &charges[x * CHARGES_PER_CELL]);
            }
          }
          for (numX = 0; numX < cellArrayDimX; numX++) {
            when xAllToAll(int n, double remoteCharges[n]) atomic {
              //CkPrintf("(%d,%d): xAllToAll\n", thisIndex.x, thisIndex.y);
              memcpy(&charges[numX * CHARGES_PER_CELL], remoteCharges, n);
            }
          }
          atomic {
            for (int i = 0; i < CHARGES_PER_CELL * cellArrayDimZ; i++) {
              charges[i] += 10.8 * i;
            }
          }
          atomic {
            for (int y = 0; y < cellArrayDimY; y++) {
              thisProxy(thisIndex.x,y).yAllToAll(CHARGES_PER_CELL, &charges[y * CHARGES_PER_CELL]);
            }
          }
          for (numY = 0; numY < cellArrayDimY; numY++) {
            when yAllToAll(int n, double remoteCharges[n]) atomic {
              memcpy(&charges[numY * CHARGES_PER_CELL], remoteCharges, n);
            }
          }
          atomic {
            for (int i = 0; i < CHARGES_PER_CELL * cellArrayDimZ; i++) {
              charges[i] += 10.8 * i;
            }
          }
          if (phase == 0) {
            atomic {
              for (int i = 0; i < CHARGES_PER_CELL * cellArrayDimZ; i++) {
                charges[i] *= 0.454;
              }
            }
          } else if (phase == 1) {
            atomic {
              for (int i = 0; i < CHARGES_PER_CELL * cellArrayDimZ; i++) {
                charges[i] += 0.3884;
              }
            }
          }
        }
        for (numZ = 0; numZ < cellArrayDimZ; numZ++) {
          atomic {
            cellArray(thisIndex.x,thisIndex.y,numZ).
              updateCharge(CHARGES_PER_CELL, &charges[numZ * CHARGES_PER_CELL]);
          }
        }
      }
      
    };
  };

};
